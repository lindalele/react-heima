{
  // 泛型用于比如函数   如果 参数是数字，那么返回值就是数字，如果接受一个字符串，那么返回值就是字符串
  // 但是如果用你any，就失去了类型检查的作用
  // 这个时候就可以用泛型

  // function fn(num: number): number {
  //   return num
  // }

  // fn(10)

  // 泛型函数：在函数名称后面加上<>,<里面是类型变量可以叫Type，T也行，其他名称也行>，
  // T是一个类型变量
  // 这句话的涵义就是参数是传了什么值类型，返回值就是什么类型
  // 声明泛型函数的时候一定要后面<>，才能表示泛型函数
  function fn<T>(value: T): T {
    return value
  }
  // 使用方法：调用的时候，函数名后面加上类型
  fn<string>('abc')
  // fn<number>(123)
  // 泛型函数调用的时候，可以不写类型，ts会自动推断；但是定义泛型函数functiion的时候一定要加上泛型<>
  let str = fn('abc')

  // 注意复杂类型，不好推论。比如参数是空数组或空对象，那么返回值就是空数组或空对象，不能推断里面的内容
  // 这时需要显式地传入类型参数
  fn([])
  // fn({})

  // [{name: 'zs', age: 19}, {name: 'ls', age: 20}]
  // useState<>([])
}
